package com.elvaco.mvp.web.api;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.elvaco.mvp.core.exception.EmailAddressAlreadyExists;
import com.elvaco.mvp.core.exception.InvalidDisplayQuantity;
import com.elvaco.mvp.core.exception.InvalidFormat;
import com.elvaco.mvp.core.exception.InvalidId;
import com.elvaco.mvp.core.exception.InvalidMeasumentRequestScope;
import com.elvaco.mvp.core.exception.InvalidMeterDefinition;
import com.elvaco.mvp.core.exception.InvalidUserSelection;
import com.elvaco.mvp.core.exception.NoPhysicalMeters;
import com.elvaco.mvp.core.exception.NoSuchQuantity;
import com.elvaco.mvp.core.exception.PredicateConstructionFailure;
import com.elvaco.mvp.core.exception.Unauthorized;
import com.elvaco.mvp.core.exception.UnitConversionError;
import com.elvaco.mvp.core.exception.UpstreamServiceUnavailable;
import com.elvaco.mvp.web.dto.ErrorMessageDto;
import com.elvaco.mvp.web.exception.MissingParameter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.MultipartException;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

@Slf4j
@ControllerAdvice
public class ApiExceptionHandler {

  private static final Pattern STRIP_AFTER_SEMI_COLON = Pattern.compile("([^;]+);");
  private static final Map<String, String> TYPE_TO_HUMAN_TYPE_MAP = new HashMap<>();

  static {
    TYPE_TO_HUMAN_TYPE_MAP.put("java.time.ZonedDateTime", "timestamp");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.UUID", "ID");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.List", "list");
  }

  /**
   * Handler for REST API exceptions.
   *
   * @param exception The exception to handle
   *
   * @return A {@link ResponseEntity} containing the {@link ErrorMessageDto} generated by the
   *   raised exception
   */
  @ExceptionHandler
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Exception exception) throws Exception {
    return handleOrRethrowGeneralException(exception);
  }

  @ExceptionHandler(IOException.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(IOException exception) throws IOException {
    if (exception.getClass().getSimpleName().equals("ClientAbortException")) {
      log.info(
        "Ignoring '{}' caused by '{}'",
        exception.getClass().getName(),
        exception.getCause().getMessage()
      );
      log.debug("Exception occurred while processing request", exception);
      return null;
    } else {
      return handleOrRethrowGeneralException(exception);
    }
  }

  @ExceptionHandler(Unauthorized.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Unauthorized exception) {
    log.info("Unauthorized", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(AccessDeniedException exception) {
    log.info("Access denied", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(MissingServletRequestParameterException.class)
  public ResponseEntity<ErrorMessageDto> handle(MissingServletRequestParameterException exception) {
    String message = String.format("Missing '%s' parameter.", exception.getParameterName());
    return badRequest(message);
  }

  @ExceptionHandler(MethodArgumentTypeMismatchException.class)
  public ResponseEntity<ErrorMessageDto> handle(MethodArgumentTypeMismatchException exception) {
    Object value = exception.getValue();
    Class<?> requiredType = exception.getRequiredType();
    String humanTypeName = humanTypeName(requiredType);
    String message = String.format(
      "Invalid '%s' %s: '%s'.",
      exception.getName(),
      humanTypeName,
      value
    );
    return badRequest(message);
  }

  @ExceptionHandler(MultipartException.class)
  public ResponseEntity<ErrorMessageDto> handle(MultipartException exception) {
    return badRequest(exception);
  }

  /**
   * Thrown for example when we try to map strings to UUID in the JPA layer,
   * and Spring's AOP wraps the exception.
   */
  @ExceptionHandler(InvalidDataAccessApiUsageException.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidDataAccessApiUsageException exception) {
    Matcher matcher = STRIP_AFTER_SEMI_COLON.matcher(exception.getMessage());
    return badRequest(matcher.find() ? matcher.group(1) : exception.getMessage());
  }

  @ExceptionHandler(PredicateConstructionFailure.class)
  public ResponseEntity<ErrorMessageDto> handle(PredicateConstructionFailure exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(UnitConversionError.class)
  public ResponseEntity<ErrorMessageDto> handle(UnitConversionError exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(NoSuchQuantity.class)
  public ResponseEntity<ErrorMessageDto> handle(NoSuchQuantity exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(InvalidFormat.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidFormat exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(InvalidId.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidId exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(InvalidMeterDefinition.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidMeterDefinition exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(InvalidDisplayQuantity.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidDisplayQuantity exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(EmailAddressAlreadyExists.class)
  public ResponseEntity<ErrorMessageDto> handle(EmailAddressAlreadyExists exception) {
    return forbidden(exception);
  }

  @ExceptionHandler(NoPhysicalMeters.class)
  public ResponseEntity<ErrorMessageDto> handle(NoPhysicalMeters exception) {
    return notFound(exception);
  }

  @ExceptionHandler(UpstreamServiceUnavailable.class)
  public ResponseEntity<ErrorMessageDto> handle(UpstreamServiceUnavailable exception) {
    ErrorMessageDto dto = new ErrorMessageDto(
      exception.getMessage(),
      HttpStatus.GATEWAY_TIMEOUT.value()
    );
    return new ResponseEntity<>(dto, HttpStatus.SERVICE_UNAVAILABLE);
  }

  @ExceptionHandler(InvalidUserSelection.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidUserSelection exception) {
    ErrorMessageDto dto = new ErrorMessageDto(
      "Invalid configuration of sub-organisation, please contact support",
      HttpStatus.FORBIDDEN.value()
    );
    log.warn("Forbidden", exception);
    return new ResponseEntity<>(dto, HttpStatus.FORBIDDEN);
  }

  @ExceptionHandler(MissingParameter.class)
  public ResponseEntity<ErrorMessageDto> handle(MissingParameter exception) {
    return badRequest(exception);
  }

  @ExceptionHandler(InvalidMeasumentRequestScope.class)
  public ResponseEntity<ErrorMessageDto> handle(InvalidMeasumentRequestScope exception) {
    return badRequest(exception);
  }

  private <T extends Exception> ResponseEntity<ErrorMessageDto> handleOrRethrowGeneralException(
    T exception
  ) throws T {
    log.warn("Exception occurred while processing request", exception);
    ApiExceptionInformation exceptionInformation = resolveHttpStatus(exception)
      .orElseThrow(() -> exception);
    return new ResponseEntity<>(exceptionInformation.dto, exceptionInformation.status);
  }

  private static Optional<ApiExceptionInformation> resolveHttpStatus(Exception exception) {
    return Optional.ofNullable(findMergedAnnotation(exception.getClass(), ResponseStatus.class))
      .map(responseStatus ->
        new ApiExceptionInformation(
          new ErrorMessageDto(exception.getMessage(), responseStatus.value().value()),
          responseStatus.value()
        ));
  }

  private static String humanTypeName(Class<?> javaType) {
    if (javaType == null) {
      return "parameter";
    }
    return TYPE_TO_HUMAN_TYPE_MAP.getOrDefault(javaType.getName(), "parameter");
  }

  private static ResponseEntity<ErrorMessageDto> badRequest(Exception e) {
    return badRequest(e.getMessage());
  }

  private static ResponseEntity<ErrorMessageDto> badRequest(String message) {
    return httpError(message, HttpStatus.BAD_REQUEST);
  }

  private static ResponseEntity<ErrorMessageDto> internalServerError(String message) {
    return httpError(message, HttpStatus.INTERNAL_SERVER_ERROR);
  }

  private static ResponseEntity<ErrorMessageDto> forbidden(Exception exception) {
    return httpError(exception.getMessage(), HttpStatus.FORBIDDEN);
  }

  private static ResponseEntity<ErrorMessageDto> notFound(Exception exception) {
    return httpError(exception.getMessage(), HttpStatus.NOT_FOUND);
  }

  private static ResponseEntity<ErrorMessageDto> httpError(String message, HttpStatus status) {
    ErrorMessageDto dto = new ErrorMessageDto(message, status.value());
    return new ResponseEntity<>(dto, status);
  }

  private static class ApiExceptionInformation {

    private final ErrorMessageDto dto;
    private final HttpStatus status;

    private ApiExceptionInformation(ErrorMessageDto dto, HttpStatus status) {
      this.dto = dto;
      this.status = status;
    }
  }
}
