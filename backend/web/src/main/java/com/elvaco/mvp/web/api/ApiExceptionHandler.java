package com.elvaco.mvp.web.api;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import com.elvaco.mvp.core.exception.Unauthorized;
import com.elvaco.mvp.web.dto.ErrorMessageDto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

@Slf4j
@ControllerAdvice
public class ApiExceptionHandler {

  static final String INTERNAL_ERROR_MESSAGE =
    "Internal server error, please contact support.";
  private static final Map<String, String> TYPE_TO_HUMAN_TYPE_MAP = new HashMap<String, String>();

  /**
   * Handler for REST API exceptions.
   *
   * @param exception The exception to handle
   * @return A {@link ResponseEntity} containing the {@link ErrorMessageDto} generated by the
   *   raised exception
   */
  @ExceptionHandler
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Exception exception) {
    log.warn("Exception occurred while processing request", exception);
    ApiExceptionInformation exceptionInformation = resolveHttpStatus(exception);
    return new ResponseEntity<>(exceptionInformation.dto, exceptionInformation.status);
  }

  @ExceptionHandler(Unauthorized.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Unauthorized exception) {
    log.info("Unauthorized", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(AccessDeniedException exception) {
    log.info("Access denied", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(MethodArgumentTypeMismatchException.class)
  public ResponseEntity<ErrorMessageDto> handle(MethodArgumentTypeMismatchException exception) {
    return badRequest(exception);
  }

  private ApiExceptionInformation resolveHttpStatus(Exception exception) {
    return Optional.ofNullable(findMergedAnnotation(exception.getClass(), ResponseStatus.class))
      .map(responseStatus ->
             new ApiExceptionInformation(
               new ErrorMessageDto(exception.getMessage(), responseStatus.value().value()),
               responseStatus.value()
             ))
      .orElse(
        new ApiExceptionInformation(
          new ErrorMessageDto(INTERNAL_ERROR_MESSAGE, HttpStatus.INTERNAL_SERVER_ERROR.value()),
          HttpStatus.INTERNAL_SERVER_ERROR
        )
      );
  }

  private String humanTypeName(String javaType) {
    return TYPE_TO_HUMAN_TYPE_MAP.getOrDefault(javaType, "parameter");
  }

  private ResponseEntity<ErrorMessageDto> badRequest(
    MethodArgumentTypeMismatchException
      exception
  ) {
    HttpStatus responseHttpStatus = HttpStatus.BAD_REQUEST;
    String message = String.format(
      "Invalid '%s' %s: '%s'.",
      exception.getName(),
      humanTypeName(exception.getRequiredType().getName()),
      exception.getValue().toString()
    );

    ErrorMessageDto dto = new ErrorMessageDto(
      message,
      responseHttpStatus.value()
    );
    return new ResponseEntity<>(dto, responseHttpStatus);
  }

  private ResponseEntity<ErrorMessageDto> forbidden(Exception exception) {
    HttpStatus responseHttpStatus = HttpStatus.FORBIDDEN;
    ErrorMessageDto dto = new ErrorMessageDto(
      exception.getMessage(),
      responseHttpStatus.value()
    );
    return new ResponseEntity<>(dto, responseHttpStatus);
  }

  private static class ApiExceptionInformation {

    private final ErrorMessageDto dto;
    private final HttpStatus status;

    ApiExceptionInformation(ErrorMessageDto dto, HttpStatus status) {
      this.dto = dto;
      this.status = status;
    }
  }

  static {
    TYPE_TO_HUMAN_TYPE_MAP.put("java.time.ZonedDateTime", "timestamp");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.UUID", "ID");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.List", "list");
  }

}
