package com.elvaco.mvp.web.api;

import java.util.Optional;

import com.elvaco.mvp.core.exception.Unauthorized;
import com.elvaco.mvp.web.dto.ErrorMessageDto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

@Slf4j
@ControllerAdvice
public class ApiExceptionHandler {

  static final String INTERNAL_ERROR_MESSAGE =
    "Internal server error, please contact support.";

  /**
   * Handler for REST API exceptions.
   *
   * @param exception The exception to handle
   * @return A {@link ResponseEntity} containing the {@link ErrorMessageDto} generated by the
   *   raised exception
   */
  @ExceptionHandler
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Exception exception) {
    log.warn("Exception occurred while processing request", exception);
    ApiExceptionInformation exceptionInformation = resolveHttpStatus(exception);
    return new ResponseEntity<>(exceptionInformation.dto, exceptionInformation.status);
  }

  @ExceptionHandler(Unauthorized.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Unauthorized exception) {
    log.info("Unauthorized", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(AccessDeniedException exception) {
    log.info("Access denied", exception);
    return forbidden(exception);
  }

  private ApiExceptionInformation resolveHttpStatus(Exception exception) {
    return Optional.ofNullable(findMergedAnnotation(exception.getClass(), ResponseStatus.class))
      .map(responseStatus ->
             new ApiExceptionInformation(
               new ErrorMessageDto(exception.getMessage(), responseStatus.value().value()),
               responseStatus.value()
             ))
      .orElse(
        new ApiExceptionInformation(
          new ErrorMessageDto(INTERNAL_ERROR_MESSAGE, HttpStatus.INTERNAL_SERVER_ERROR.value()),
          HttpStatus.INTERNAL_SERVER_ERROR
        )
      );
  }

  private ResponseEntity<ErrorMessageDto> forbidden(Exception exception) {
    HttpStatus responseHttpStatus = HttpStatus.FORBIDDEN;
    ErrorMessageDto dto = new ErrorMessageDto(
      exception.getMessage(),
      responseHttpStatus.value()
    );
    return new ResponseEntity<>(dto, responseHttpStatus);
  }

  private static class ApiExceptionInformation {

    private final ErrorMessageDto dto;
    private final HttpStatus status;

    ApiExceptionInformation(ErrorMessageDto dto, HttpStatus status) {
      this.dto = dto;
      this.status = status;
    }
  }

}
