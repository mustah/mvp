package com.elvaco.mvp.web.api;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import com.elvaco.mvp.core.exception.EmailAddressAlreadyExists;
import com.elvaco.mvp.core.exception.PredicateConstructionFailure;
import com.elvaco.mvp.core.exception.Unauthorized;
import com.elvaco.mvp.core.exception.UnitConversionError;
import com.elvaco.mvp.core.exception.UpstreamServiceUnavailable;
import com.elvaco.mvp.web.dto.ErrorMessageDto;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import static org.springframework.core.annotation.AnnotatedElementUtils.findMergedAnnotation;

@Slf4j
@ControllerAdvice
public class ApiExceptionHandler {

  static final String INTERNAL_ERROR_MESSAGE = "Internal server error, please contact support.";

  private static final ApiExceptionInformation INTERNAL_SERVER_ERROR =
    new ApiExceptionInformation(
      new ErrorMessageDto(INTERNAL_ERROR_MESSAGE, HttpStatus.INTERNAL_SERVER_ERROR.value()),
      HttpStatus.INTERNAL_SERVER_ERROR
    );

  private static final Map<String, String> TYPE_TO_HUMAN_TYPE_MAP = new HashMap<>();

  /**
   * Handler for REST API exceptions.
   *
   * @param exception The exception to handle
   * @return A {@link ResponseEntity} containing the {@link ErrorMessageDto} generated by the
   *   raised exception
   */
  @ExceptionHandler
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Exception exception) {
    log.warn("Exception occurred while processing request", exception);
    ApiExceptionInformation exceptionInformation = resolveHttpStatus(exception);
    return new ResponseEntity<>(exceptionInformation.dto, exceptionInformation.status);
  }

  @ExceptionHandler(Unauthorized.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(Unauthorized exception) {
    log.info("Unauthorized", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(AccessDeniedException.class)
  @ResponseBody
  public ResponseEntity<ErrorMessageDto> handle(AccessDeniedException exception) {
    log.info("Access denied", exception);
    return forbidden(exception);
  }

  @ExceptionHandler(MissingServletRequestParameterException.class)
  public ResponseEntity<ErrorMessageDto> handle(MissingServletRequestParameterException exception) {
    String message = String.format("Missing '%s' parameter.", exception.getParameterName());
    return badRequest(message);
  }

  @ExceptionHandler(MethodArgumentTypeMismatchException.class)
  public ResponseEntity<ErrorMessageDto> handle(MethodArgumentTypeMismatchException exception) {
    String message = String.format(
      "Invalid '%s' %s: '%s'.",
      exception.getName(),
      humanTypeName(exception.getRequiredType().getName()),
      exception.getValue().toString()
    );
    return badRequest(message);
  }

  @ExceptionHandler(PredicateConstructionFailure.class)
  public ResponseEntity<ErrorMessageDto> handle(PredicateConstructionFailure exception) {
    return badRequest(exception.getMessage());
  }

  @ExceptionHandler(UnitConversionError.class)
  public ResponseEntity<ErrorMessageDto> handle(UnitConversionError exception) {
    return badRequest(exception.getMessage());
  }

  @ExceptionHandler(EmailAddressAlreadyExists.class)
  public ResponseEntity<ErrorMessageDto> handle(EmailAddressAlreadyExists exception) {
    return forbidden(exception);
  }

  @ExceptionHandler(UpstreamServiceUnavailable.class)
  public ResponseEntity<ErrorMessageDto> handle(UpstreamServiceUnavailable exception) {
    ErrorMessageDto dto = new ErrorMessageDto(
      exception.getMessage(),
      HttpStatus.GATEWAY_TIMEOUT.value()
    );
    return new ResponseEntity<>(dto, HttpStatus.SERVICE_UNAVAILABLE);
  }

  private static ApiExceptionInformation resolveHttpStatus(Exception exception) {
    return Optional.ofNullable(findMergedAnnotation(exception.getClass(), ResponseStatus.class))
      .map(responseStatus ->
        new ApiExceptionInformation(
          new ErrorMessageDto(exception.getMessage(), responseStatus.value().value()),
          responseStatus.value()
        ))
      .orElse(INTERNAL_SERVER_ERROR);
  }

  private static String humanTypeName(String javaType) {
    return TYPE_TO_HUMAN_TYPE_MAP.getOrDefault(javaType, "parameter");
  }

  private static ResponseEntity<ErrorMessageDto> badRequest(String message) {
    ErrorMessageDto dto = new ErrorMessageDto(message, HttpStatus.BAD_REQUEST.value());
    return new ResponseEntity<>(dto, HttpStatus.BAD_REQUEST);
  }

  private static ResponseEntity<ErrorMessageDto> forbidden(Exception exception) {
    ErrorMessageDto dto = new ErrorMessageDto(exception.getMessage(), HttpStatus.FORBIDDEN.value());
    return new ResponseEntity<>(dto, HttpStatus.FORBIDDEN);
  }

  private static class ApiExceptionInformation {

    private final ErrorMessageDto dto;
    private final HttpStatus status;

    private ApiExceptionInformation(ErrorMessageDto dto, HttpStatus status) {
      this.dto = dto;
      this.status = status;
    }
  }

  static {
    TYPE_TO_HUMAN_TYPE_MAP.put("java.time.ZonedDateTime", "timestamp");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.UUID", "ID");
    TYPE_TO_HUMAN_TYPE_MAP.put("java.util.List", "list");
  }
}
